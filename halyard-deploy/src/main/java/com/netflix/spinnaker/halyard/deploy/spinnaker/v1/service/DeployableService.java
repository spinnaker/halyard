/*
 * Copyright 2017 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.netflix.spinnaker.halyard.deploy.spinnaker.v1.service;

import com.netflix.spinnaker.clouddriver.orchestration.AtomicOperations;
import com.netflix.spinnaker.halyard.config.model.v1.node.Account;
import com.netflix.spinnaker.halyard.config.model.v1.node.Provider;
import com.netflix.spinnaker.halyard.deploy.deployment.v1.AccountDeploymentDetails;
import com.netflix.spinnaker.halyard.deploy.services.v1.GenerateService;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.RunningServiceDetails;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This interface represents the cloud-environments specific information/operations required to install a service.
 * @param <T> is the type of the service interface being deployed, e.g ClouddriverService.Clouddriver.
 * @param <A> is the type of an account in this cloud provider.
 */
public interface DeployableService<T, A extends Account> extends HasServiceSettings<T> {
  String getSpinnakerStagingPath();

  Map<String, Object> getLoadBalancerDescription(AccountDeploymentDetails<A> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration);
  Map<String, Object> getServerGroupDescription(AccountDeploymentDetails<A> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration,
      List<ConfigSource> configSources);
  List<ConfigSource> stageProfiles(AccountDeploymentDetails<A> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration);
  void ensureRunning(AccountDeploymentDetails<A> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration,
      List<ConfigSource> configSources,
      boolean recreate);


  List<String> getHealthProviders();
  Map<String, List<String>> getAvailabilityZones();
  String getRegion();
  Provider.ProviderType getProviderType();
  RunningServiceDetails getRunningServiceDetails(AccountDeploymentDetails<A> details);
  String getName();
  SpinnakerMonitoringDaemonService getMonitoringDaemonService();
  T connect(AccountDeploymentDetails<A> details, GenerateService.ResolvedConfiguration resolvedConfiguration);
  String connectCommand(AccountDeploymentDetails<A> details, GenerateService.ResolvedConfiguration resolvedConfiguration);
  void deleteVersion(AccountDeploymentDetails<A> details, String version);
  boolean isRequiredToBootstrap();
  DeployPriority getDeployPriority();
  SpinnakerService<T> getService();

  default Map<String, Object> buildDeployServerGroupPipeline(AccountDeploymentDetails<A> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration,
      List<ConfigSource> configSources) {
    Map<String, Object> deployDescription  = getServerGroupDescription(details, resolvedConfiguration, configSources);
    deployDescription.put("interestingHealthProviders", getHealthProviders());
    deployDescription.put("type", AtomicOperations.CREATE_SERVER_GROUP);
    deployDescription.put("cloudProvider", getProviderType().getId());
    deployDescription.put("refId", "deployredblack");
    deployDescription.put("region", getRegion());
    deployDescription.put("strategy", "redblack");
    /* TODO(lwander)
    deployDescription.put("maxRemainingAsgs", maxRemaining + "");
    deployDescription.put("scaleDown", scaleDown + "");
    */

    List<Map<String, Object>> stages = new ArrayList<>();
    stages.add(deployDescription);

    Map<String, Object> pipeline = new HashMap<>();
    pipeline.put("stages", stages);
    pipeline.put("application", "spin");
    pipeline.put("name", "Deploy/Upgrade " + getName());
    pipeline.put("description", "Auto-generated by Halyard");
    return pipeline;
  }

  default Map<String, Object> buildUpsertLoadBalancerTask(AccountDeploymentDetails<A> details, GenerateService.ResolvedConfiguration resolvedConfiguration) {
    Map<String, Object> upsertDescription = getLoadBalancerDescription(details, resolvedConfiguration);
    upsertDescription.put("type", AtomicOperations.UPSERT_LOAD_BALANCER);
    upsertDescription.put("cloudProvider", getProviderType().getId());
    upsertDescription.put("refId", "upsertlb");
    upsertDescription.put("application", "spin");
    upsertDescription.put("availabilityZones", getAvailabilityZones());

    List<Map<String, Object>> job = new ArrayList<>();
    job.add(upsertDescription);

    Map<String, Object> task = new HashMap<>();
    task.put("job", job);
    task.put("application", "spin");
    task.put("name", "Upsert LB of " + getName());
    task.put("description", "Auto-generated by Halyard");
    return task;
  }

  // Used to ensure dependencies are deployed first. The higher the priority, the sooner the service is deployed.
  class DeployPriority {
    final Integer priority;
    public DeployPriority(Integer priority) {
      this.priority = priority;
    }

    public int compareTo(DeployPriority other) {
      return this.priority.compareTo(other.priority);
    }
  }
}
