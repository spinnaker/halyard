/*
 * Copyright 2017 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.netflix.spinnaker.halyard.deploy.spinnaker.v1.service.distributed.google;

import com.google.api.services.compute.Compute;
import com.google.api.services.compute.model.*;
import com.netflix.frigga.Names;
import com.netflix.spinnaker.halyard.config.model.v1.node.Provider;
import com.netflix.spinnaker.halyard.config.model.v1.providers.google.GoogleAccount;
import com.netflix.spinnaker.halyard.core.error.v1.HalException;
import com.netflix.spinnaker.halyard.core.tasks.v1.DaemonTaskHandler;
import com.netflix.spinnaker.halyard.deploy.deployment.v1.AccountDeploymentDetails;
import com.netflix.spinnaker.halyard.deploy.services.v1.ArtifactService;
import com.netflix.spinnaker.halyard.deploy.services.v1.GenerateService;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.RunningServiceDetails;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.SpinnakerRuntimeSettings;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.profile.Profile;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.service.*;
import com.netflix.spinnaker.halyard.deploy.spinnaker.v1.service.distributed.*;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.http.client.utils.URIBuilder;

import java.io.IOException;
import java.net.URI;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import static com.netflix.spinnaker.halyard.core.problem.v1.Problem.Severity.FATAL;

public interface GoogleDistributedService<T> extends DistributedService<T, GoogleAccount> {
  GoogleVaultServerService getVaultServerService();
  GoogleConsulServerService getConsulServerService();
  ArtifactService getArtifactService();
  ServiceInterfaceFactory getServiceInterfaceFactory();
  String getGoogleImageProject();
  String getStartupScriptPath();

  default String buildAddress() {
    return String.format("%s.service.spinnaker.consul", getService().getCanonicalName());
  }

  default String getEnvFile() {
    return "/etc/default/spinnaker";
  }

  default List<SidecarService> getSidecars(SpinnakerRuntimeSettings runtimeSettings) {
    SpinnakerMonitoringDaemonService monitoringService = getMonitoringDaemonService();
    ServiceSettings monitoringSettings = runtimeSettings.getServiceSettings(monitoringService);
    ServiceSettings thisSettings = runtimeSettings.getServiceSettings(getService());

    List<SidecarService> result = new ArrayList<>();
    if (monitoringSettings.isEnabled() && thisSettings.isMonitored()) {
      result.add(monitoringService);
    }

    return result;
  }

  default List<String> getScopes() {
    List<String> result = new ArrayList<>();
    result.add("https://www.googleapis.com/auth/devstorage.read_only");
    result.add("https://www.googleapis.com/auth/logging.write");
    result.add("https://www.googleapis.com/auth/monitoring.write");
    result.add("https://www.googleapis.com/auth/servicecontrol");
    result.add("https://www.googleapis.com/auth/service.management.readonly");
    result.add("https://www.googleapis.com/auth/trace.append");

    return result;
  }

  @Override
  default Provider.ProviderType getProviderType() {
    return Provider.ProviderType.GOOGLE;
  }

  default String getStartupScript() {
    return String.join("\n", "#!/usr/bin/env bash",
        "",
        "# AUTO-GENERATED BY HALYARD",
        "",
        getStartupScriptPath() + "startup.sh google");
  }

  default String getArtifactId(String deploymentName) {
    String artifactName = getArtifact().getName();
    String version = getArtifactService().getArtifactVersion(deploymentName, getArtifact());
    return String.format("projects/%s/global/images/%s",
        getGoogleImageProject(),
        String.join("-", "spinnaker", artifactName, version.replace(".", "-").replace(":", "-")));
  }

  default VaultConnectionDetails buildConnectionDetails(AccountDeploymentDetails<GoogleAccount> details, SpinnakerRuntimeSettings runtimeSettings, String secretName) {
    GoogleVaultServerService vaultService = getVaultServerService();
    VaultServerService.Vault vault = vaultService.connect(details, runtimeSettings);

    ServiceSettings vaultSettings = runtimeSettings.getServiceSettings(vaultService);
    RunningServiceDetails vaultDetails = vaultService.getRunningServiceDetails(details, vaultSettings);
    Integer latestVaultVersion = vaultDetails.getLatestEnabledVersion();
    if (latestVaultVersion == null) {
      throw new IllegalStateException("No vault services have been started yet. This is a bug.");
    }

    List<RunningServiceDetails.Instance> instances = vaultDetails.getInstances().get(vaultDetails.getLatestEnabledVersion());
    if (instances.isEmpty()) {
      throw new IllegalStateException("Current vault service has no running instances. This is a bug.");
    }

    String instanceId = instances.get(0).getId();
    String address = new URIBuilder().setScheme("http").setHost(instanceId).setPort(vaultSettings.getPort()).toString();

    String token = vaultService.getToken(details.getDeploymentName(), vault);

    return new VaultConnectionDetails().setAddress(address).setSecret(secretName).setToken(token);
  }

  @Override
  default List<ConfigSource> stageProfiles(AccountDeploymentDetails<GoogleAccount> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration) {

    String deploymentName = details.getDeploymentName();
    SpinnakerService thisService = getService();
    ServiceSettings thisServiceSettings = resolvedConfiguration.getServiceSettings(thisService);
    Map<String, String> env = new HashMap<>();
    Integer version = getLatestEnabledServiceVersion(details, thisServiceSettings);
    if (version == null) {
      version = 0;
    } else {
      version++;
    }

    List<ConfigSource> configSources = new ArrayList<>();
    String stagingPath = getSpinnakerStagingPath();
    GoogleVaultServerService vaultService = getVaultServerService();
    VaultServerService.Vault vault = vaultService.connect(details, resolvedConfiguration.getRuntimeSettings());

    for (SidecarService sidecarService : getSidecars(resolvedConfiguration.getRuntimeSettings())) {
      for (Profile profile : sidecarService.getSidecarProfiles(resolvedConfiguration, thisService)) {
        String secretName = secretName(profile.getName(), version);
        String mountPoint = Paths.get(profile.getOutputFile()).toString();
        Path stagedFile = Paths.get(profile.getStagedFile(stagingPath));
        VaultConfigMount vaultConfigMount = VaultConfigMount.fromLocalFile(stagedFile.toFile(), mountPoint);
        secretName = vaultService.writeVaultConfig(deploymentName, vault, secretName, vaultConfigMount);

        configSources.add(new ConfigSource().setId(secretName).setMountPath(mountPoint));
      }
    }

    Map<String, Profile> serviceProfiles = resolvedConfiguration.getProfilesForService(thisService.getType());
    Set<String> requiredFiles = new HashSet<>();

    for (Map.Entry<String, Profile> entry : serviceProfiles.entrySet()) {
      Profile profile = entry.getValue();
      requiredFiles.addAll(profile.getRequiredFiles());
      env.putAll(profile.getEnv());

      String mountPoint = profile.getOutputFile();
      String secretName = secretName("profile-" + profile.getName(), version);
      Path stagedFile = Paths.get(profile.getStagedFile(stagingPath));
      VaultConfigMount vaultConfigMount = VaultConfigMount.fromLocalFile(stagedFile.toFile(), mountPoint);
      secretName = vaultService.writeVaultConfig(deploymentName, vault, secretName, vaultConfigMount);

      configSources.add(new ConfigSource().setId(secretName).setMountPath(mountPoint));
    }

    for (String file : requiredFiles) {
      String mountPoint = Paths.get(file).toString();
      String secretName = secretName("dependencies-" + file, version);
      VaultConfigMount vaultConfigMount = VaultConfigMount.fromLocalFile(Paths.get(file).toFile(), mountPoint);
      secretName = vaultService.writeVaultConfig(deploymentName, vault, secretName, vaultConfigMount);

      configSources.add(new ConfigSource().setId(secretName).setMountPath(mountPoint));
    }

    env.putAll(thisServiceSettings.getEnv());

    String envSourceFile = env.entrySet()
        .stream()
        .reduce("",
            (s, e) -> String.format("%s\n%s=%s", s, e.getKey(), e.getValue()),
            (s1, s2) -> String.join("\n", s1, s2)
        );

    String mountPoint = getEnvFile();
    String secretName = secretName("env", version);
    VaultConfigMount vaultConfigMount = VaultConfigMount.fromString(envSourceFile, mountPoint);
    secretName = vaultService.writeVaultConfig(deploymentName, vault, secretName, vaultConfigMount);

    configSources.add(new ConfigSource().setId(secretName).setMountPath(mountPoint));

    return configSources;
  }

  default String secretName(String detail, int version) {
    return String.join("-",
        "hal",
        getService().getType().getCanonicalName(),
        detail,
        version + "",
        RandomStringUtils.random(5, true, true));
  }

  @Override
  default void ensureRunning(AccountDeploymentDetails<GoogleAccount> details,
      GenerateService.ResolvedConfiguration resolvedConfiguration,
      List<ConfigSource> configSources,
      boolean recreate) {
    int version = 0;
    ServiceSettings settings = resolvedConfiguration.getServiceSettings(getService());
    RunningServiceDetails runningServiceDetails = getRunningServiceDetails(details, settings);

    String deploymentName = details.getDeploymentName();
    GoogleAccount account = details.getAccount();
    Compute compute = GoogleProviderUtils.getCompute(details);
    String project = account.getProject();

    boolean exists = runningServiceDetails.getLatestEnabledVersion() != null;
    if (!recreate && exists) {
      DaemonTaskHandler.message("Service " + getServiceName() + " is already deployed and not safe to restart.");
      return;
    } else if (exists) {
      DaemonTaskHandler.message("Recreating existing " + getServiceName() + "...");
      try {
        // TODO delete corresponding instance template here too (right now it's useful to keep for debugging, though).
        Operation operation = compute.instanceGroupManagers().delete(project, settings.getLocation(), getVersionedName(version)).execute();
        GoogleProviderUtils.waitOnZoneOperation(compute, project, settings.getLocation(), operation);
      } catch (IOException e) {
        throw new HalException(FATAL, "Failed to delete service " + getServiceName(), e);
      }
    }

    InstanceGroupManager manager = new InstanceGroupManager();

    InstanceTemplate template = new InstanceTemplate()
        .setName(getServiceName() + "-hal-" + System.currentTimeMillis())
        .setDescription("Halyard-generated instance template for deploying Spinnaker");

    Metadata.Items items = new Metadata.Items()
        .setKey("startup-script")
        .setValue(getStartupScript());

    List<Metadata.Items> metadataItems = new ArrayList<>();
    metadataItems.add(items);

    if (!configSources.isEmpty()) {
      GoogleVaultServerService vaultService = getVaultServerService();
      VaultServerService.Vault vault = vaultService.connect(details, resolvedConfiguration.getRuntimeSettings());

      String secretName = secretName("config-mounts", version);
      VaultConfigMountSet mountSet = VaultConfigMountSet.fromConfigSources(configSources);
      secretName = vaultService.writeVaultConfigMountSet(deploymentName, vault, secretName, mountSet);

      VaultConnectionDetails connectionDetails = buildConnectionDetails(details, resolvedConfiguration.getRuntimeSettings(), secretName);

      items = new Metadata.Items()
          .setKey("vault_address")
          .setValue(connectionDetails.getAddress());
      metadataItems.add(items);

      items = new Metadata.Items()
          .setKey("vault_token")
          .setValue(connectionDetails.getToken());
      metadataItems.add(items);

      items = new Metadata.Items()
          .setKey("vault_secret")
          .setValue(connectionDetails.getSecret());
      metadataItems.add(items);
    }

    GoogleConsulServerService consulServerService = getConsulServerService();
    RunningServiceDetails consulServerDetails = consulServerService.getRunningServiceDetails(details, resolvedConfiguration.getServiceSettings(consulServerService));
    Integer latestConsulVersion = consulServerDetails.getLatestEnabledVersion();
    if (latestConsulVersion != null) {
      List<RunningServiceDetails.Instance> instances = consulServerDetails.getInstances().get(latestConsulVersion);
      String instancesValue = String.join(" ", instances.stream().map(RunningServiceDetails.Instance::getId).collect(Collectors.toList()));

      items = new Metadata.Items()
          .setKey("consul-members") // TODO(lwander) change to consul_members for consistency w/ vault
          .setValue(instancesValue);

      metadataItems.add(items);
    }

    Metadata metadata = new Metadata().setItems(metadataItems);

    AccessConfig accessConfig = new AccessConfig()
        .setName("External NAT")
        .setType("ONE_TO_ONE_NAT");

    NetworkInterface networkInterface = new NetworkInterface()
        .setNetwork(GoogleProviderUtils.ensureSpinnakerNetworkExists(details))
        .setAccessConfigs(Collections.singletonList(accessConfig));

    ServiceAccount sa = new ServiceAccount()
        .setEmail(GoogleProviderUtils.defaultServiceAccount(details))
        .setScopes(getScopes());

    InstanceProperties properties = new InstanceProperties()
        .setMachineType("n1-highmem-2")
        .setMetadata(metadata)
        .setServiceAccounts(Collections.singletonList(sa))
        .setNetworkInterfaces(Collections.singletonList(networkInterface));

    AttachedDisk disk = new AttachedDisk()
        .setBoot(true);

    AttachedDiskInitializeParams diskParams = new AttachedDiskInitializeParams()
        .setSourceImage(getArtifactId(details.getDeploymentName()));

    disk.setInitializeParams(diskParams);
    List<AttachedDisk> disks = new ArrayList<>();

    disks.add(disk);
    properties.setDisks(disks);
    template.setProperties(properties);

    String instanceTemplateUrl;
    Operation operation;
    try {
      operation = compute.instanceTemplates().insert(project, template).execute();
      instanceTemplateUrl = operation.getTargetLink();
      GoogleProviderUtils.waitOnGlobalOperation(compute, project, operation);
    } catch (IOException e) {
      throw new HalException(FATAL, "Failed to create instance template for " + settings.getArtifactId() + ": " + e.getMessage(), e);
    }

    String migName = getVersionedName(version);
    manager.setInstanceTemplate(instanceTemplateUrl);
    manager.setBaseInstanceName(migName);
    manager.setTargetSize(settings.getTargetSize());
    manager.setName(migName);

    try {
      operation = compute.instanceGroupManagers().insert(project, settings.getLocation(), manager).execute();
      GoogleProviderUtils.waitOnZoneOperation(compute, project, settings.getLocation(), operation);
    } catch (IOException e) {
      throw new HalException(FATAL, "Failed to create instance group to run artifact " + settings.getArtifactId() + ": " + e.getMessage(), e);
    }

    long running = 0;
    while (running < 1) {
      running = getRunningServiceDetails(details, settings)
          .getInstances()
          .getOrDefault(version, new ArrayList<>())
          .stream()
          .filter(RunningServiceDetails.Instance::isRunning)
          .count();

      DaemonTaskHandler.safeSleep(TimeUnit.SECONDS.toMillis(1));
    }
  }

  @Override
  default Map<String, Object> getLoadBalancerDescription(AccountDeploymentDetails<GoogleAccount> details, SpinnakerRuntimeSettings runtimeSettings) {
    return new HashMap<>();
  }

  @Override
  default Map<String, Object> getServerGroupDescription(AccountDeploymentDetails<GoogleAccount> details, SpinnakerRuntimeSettings runtimeSettings, List<ConfigSource> configSources) {
    return new HashMap<>();
  }

  @Override
  default List<String> getHealthProviders() {
    return Collections.singletonList("google");
  }

  @Override
  default Map<String, List<String>> getAvailabilityZones(ServiceSettings settings) {
    Map<String, List<String>> result = new HashMap<>();
    List<String> zones = Collections.singletonList(settings.getLocation());
    result.put(getRegion(settings), zones);
    return result;
  }

  @Override
  default String getRegion(ServiceSettings settings) {
    String zone = settings.getLocation();
    return zone.substring(0, zone.lastIndexOf("-"));
  }

  @Override
  default RunningServiceDetails getRunningServiceDetails(AccountDeploymentDetails<GoogleAccount> details, ServiceSettings settings) {
    RunningServiceDetails result = new RunningServiceDetails();
    Compute compute = GoogleProviderUtils.getCompute(details);
    GoogleAccount account = details.getAccount();
    List<InstanceGroupManager> migs;
    try {
      migs = compute.instanceGroupManagers().list(account.getProject(), settings.getLocation()).execute().getItems();
    } catch (IOException e) {
      throw new HalException(FATAL, "Failed to load MIGS: " + e.getMessage(), e);
    }

    String serviceName = getService().getServiceName();

    migs = migs.stream()
        .filter(ig -> ig.getName().startsWith(serviceName))
        .collect(Collectors.toList());

    Map<Integer, List<RunningServiceDetails.Instance>> instances = migs.stream().reduce(new HashMap<>(),
        (map, mig) -> {
          Names names = Names.parseName(mig.getName());
          Integer version = names.getSequence();
          List<RunningServiceDetails.Instance> computeInstances;
          try {
            computeInstances = compute
                .instanceGroupManagers()
                .listManagedInstances(account.getProject(), settings.getLocation(), mig.getName())
                .execute()
                .getManagedInstances()
                .stream()
                .map(i -> {
                      String instanceUrl = i.getInstance();
                      String instanceStatus = i.getInstanceStatus();
                      boolean running = instanceStatus != null && instanceStatus.equalsIgnoreCase("running");
                      String instanceName = instanceUrl.substring(instanceUrl.lastIndexOf('/') + 1, instanceUrl.length());
                      return new RunningServiceDetails.Instance()
                          .setId(instanceName)
                          .setLocation(settings.getLocation())
                          .setRunning(running)
                          .setHealthy(running); // todo(lwander) depend on consul health here where possible.
                    }
                ).collect(Collectors.toList());
          } catch (IOException e) {
            throw new HalException(FATAL, "Failed to load target pools for " + serviceName, e);
          }
          map.put(version, computeInstances);
          return map;
        },
        (m1, m2) -> {
          m1.putAll(m2);
          return m1;
        });

    result.setInstances(instances);

    return result;
  }

  @Override
  default T connect(AccountDeploymentDetails<GoogleAccount> details, SpinnakerRuntimeSettings runtimeSettings) {
    ServiceSettings settings = runtimeSettings.getServiceSettings(getService());
    RunningServiceDetails runningServiceDetails = getRunningServiceDetails(details, settings);

    Integer enabledVersion = runningServiceDetails.getLatestEnabledVersion();
    if (enabledVersion == null) {
      throw new HalException(FATAL, "Cannot connect to " + getServiceName() + " when no server groups have been deployed yet");
    }

    List<RunningServiceDetails.Instance> instances = runningServiceDetails.getInstances().get(enabledVersion);

    if (instances == null || instances.isEmpty()) {
      throw new HalException(FATAL, "Cannot connect to " + getServiceName() + " when no instances have been deployed yet");
    }

    URI uri = GoogleProviderUtils.openSshTunnel(details, instances.get(0).getId(), settings);
    return getServiceInterfaceFactory().createService(uri.toString(), getService());
  }

  @Override
  default String connectCommand(AccountDeploymentDetails<GoogleAccount> details, SpinnakerRuntimeSettings runtimeSettings) {
    return null;
  }

  @Override
  default void deleteVersion(AccountDeploymentDetails<GoogleAccount> details, ServiceSettings settings, Integer version) {

  }
}
